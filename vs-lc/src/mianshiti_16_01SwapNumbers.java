/*
Write a function to swap a number in place (that is, without temporary variables).

Example:

Input: numbers = [1,2]
Output: [2,1]
Note:

numbers.length == 2
-2147483647 <= numbers[i] <= 2147483647

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/swap-numbers-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/

public class mianshiti_16_01SwapNumbers {
    
}

class Solution {
    public int[] swapNumbers(int[] numbers) {
        /*
        [x,y]->[x+y,x-y]->[((x+y)-(x-y))/2,x-y]->[y,x-y]->[y,x-y+y]
        [x,y]->[x,x-y]->[]


        [x,y]->[x+(y-x),y-(y-x)]


        为什么溢出不会影响结果：

        下面我们来分析一下当array[i]和array[j]都非常大，相加的时候出现了数字溢出，该怎么办，其实这个不用担心的，因为如果出现了溢出，最多也只能溢出一位，而int类型的最高位是符号位，是1表示的是负数，0表示的是非负数，而这个符号位是可以参与加减运算的。



我们要明白一点，在计算机中所有的加减法其实都是加法，首先是把我们要计算的数转换为二进制，然后再进行运算，负数会以补码的形式存在，当然正数的补码和原码相同。我们先来看一段非常简单的代码

1public static void main(String[] args) {
2    int a = -3;
3    int b = -5;
4    int c = a - b;//其实相当于a+(-b)；
5    System.out.println("a的值是:" + a + "-->二进制：" + Util.bitInt32(a));
6    System.out.println("-b的值是:" + -b + "-->二进制：" + Util.bitInt32(-b));
7    System.out.println("c的值是:" + c + "--> 二进制：" + Util.bitInt32(c));
8}
看一下执行的结果

图片

我们看到a+（-b）最高位其实已经出现了溢出，但这并不影响最终的结果。




        xor的性质：

        异或运算其实还是很强大的，
        比如0^a=a，a^a=0，同时他还满足交换律，比如a^b^c=a^c^b，
        ^(异或运算)不像&(与)和|(或)那么傻，
        ^(异或运算)有记忆功能，他和+，-，*，÷这些符号一样，如果知道结果和其中的一个值就可以确定另外一个值了，
        与)和|(或)就不能完全确定了。
        
        比如a&1=1或者a&1=0，我们可以确定a的值，但如果a&0=0，我们就无法确定a究竟是0还是1了。
        那我们这里就仿照+运算符来写一个



        按位异或的3个特点：

　　（1） 0^0=0，0^1=1 0异或任何数＝任何数

　　（2） 1^0=1，1^1=0 1异或任何数－任何数取反

　　（3） 任何数异或自己＝把自己置0

　　按位异或的几个常见用途：

　　（1） 使某些特定的位翻转

　　例如对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。

　　10100001^00000110 = 10100111

　　（2） 实现两个值的交换，而不必使用临时变量。

　　例如交换两个整数a=10100001，b=00000110的值，可通过下列语句实现：

　　a = a^b； 　　//a=10100111

　　b = b^a； 　　//b=10100001

　　a = a^b； 　　//a=00000110

　　（3） 在汇编语言中经常用于将变量置零：

　　xor a，a

　　（4） 快速判断两个值是否相等

　　举例1： 判断两个整数a，b是否相等，则可通过下列语句实现：

　　return （（a ^ b） == 0）
        */
    }
}